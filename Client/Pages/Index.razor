@page "/"
@using BlazorApp.Shared
@using System.Globalization
@inject HttpClient Http
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject NavigationManager NavManager
@using BlazorLeaflet.Models
@inject IJSRuntime jsRuntime

<PageTitle>PeaksHunters</PageTitle>

<div id="mapId">
    <LeafletMap Map="_map" />
</div>

<style>
    #mapId {
        height: 100%;
        width: 100%;
        position: fixed;
    }
</style>

@code
{

    private Map _map;
    protected override void OnInitialized()
    {
        _map = new Map(jsRuntime)
        {
            Center = _startAt,
            Zoom = 4.8f
        };

        _map.OnInitialized += () =>
        {
            _map.AddLayer(new TileLayer
            {
                UrlTemplate = "https://a.tile.openstreetmap.org/{z}/{x}/{y}.png",
                Attribution = "&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors",
            });
        };


        _map.OnZoomEnd += OnZoomEnds;
    }

    private void OnZoomEnds(object sender, BlazorLeaflet.Models.Events.Event e){
        Console.WriteLine("zoomend");
    }

    private LatLng _startAt = new LatLng(63.4010888f, 13.0822241f);
}

@* @code { *@
    @* private Map mapRef;
    private static LatLng initialCenter = new LatLng(63.4010888, 13.0822241);
    private int fetchRadius = 60000;
    private double cancelFetchZone = 0.3; // Cancel a new peaks fetch if within cancelFetchZone * fetchRadius
    HashSet<Peak> peaks = new HashSet<Peak>();
    Dictionary<string, List<Activity>> summitedPeaks = new Dictionary<string, List<Activity>>(); 
    Dictionary<string, Marker> markers = new Dictionary<string, Marker>();
    private MapOptions mapOptions = new MapOptions()
    {
        DivId = "mapId",
        Center = initialCenter,
        Zoom = 10,
        UrlTileLayer = "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
	SubOptions = new MapSubOptions()
        {
            Attribution = "&copy; <a href='http://www.openstreetmap.org/copyright'>OpenStreetMap</a>,  <a href='https://opentopomap.org/credits'>OpenTopoMap</a>",
            TileSize = 256,
            ZoomOffset = 0,
            MaxZoom = 18,
        }
    };

    protected override async Task OnInitializedAsync()
    {
        try
        {
            StravaTokens? tokens = await localStorage.GetItemAsync<StravaTokens>("strava_tokens");

            if (tokens == null || tokens.access_token == null){
                NavManager.NavigateTo("/authenticate");
            } else if (DateTimeOffset.Now > DateTimeOffset.FromUnixTimeSeconds(tokens.expires_at)){
                Console.WriteLine("TODO USE REFRESH TOKEN!");
                NavManager.NavigateTo("/authenticate");
            } else {
                List<LatLng> queriedLocations = new List<LatLng>();

                Task<Dictionary<string, List<Activity>>?> summitedPeaksTask = Http.GetFromJsonAsync<Dictionary<string, List<Activity>>>("/api/SummitedPeaks?access_token=" + tokens.access_token);
                
                Task peaksTask = FetchPeaks(initialCenter, queriedLocations);

                await peaksTask;
                await mapRef.OnMouseUp(async (MouseEvent mouseEvent) => await HandleMouseEvent(mouseEvent, queriedLocations));
                await UpdateMarkers();
                summitedPeaks = await summitedPeaksTask ?? new Dictionary<string, List<Activity>>();
                await UpdateMarkers();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.ToString());
        }
    }

    private async Task HandleMouseEvent(MouseEvent mouseEvent, List<LatLng> queriedLocations)
    {
        LatLng center = await mapRef.GetCenter();
        foreach (LatLng fetchedCenter in queriedLocations){
            Coordinate fetchCenter = new Coordinate(center.Lat, center.Lng);
            Coordinate previousFetchCenter = new Coordinate(fetchedCenter.Lat, fetchedCenter.Lng);
            double distance = GeoSpatialFunctions.DistanceTo(fetchCenter, previousFetchCenter);
            if (distance < fetchRadius * cancelFetchZone){
                return;
            }
        }
        await FetchPeaks(center, queriedLocations);
        await UpdateMarkers();
    }

    private async Task FetchPeaks(LatLng center, List<LatLng> queriedLocations)
    {
        string lat = center.Lat.ToString(CultureInfo.InvariantCulture);
        string lng = center.Lng.ToString(CultureInfo.InvariantCulture);
        Task<Peak[]?> peaksTask = Http.GetFromJsonAsync<Peak[]>($"/api/Peaks?lat={lat}&lon={lng}&radius={fetchRadius}");
        Peak[] newPeaks = await peaksTask ?? new Peak[]{};
        foreach(Peak peak in newPeaks){
            peaks.Add(peak);
        }
        queriedLocations.Add(center);
    }

    private async Task UpdateMarkers()
    {
        foreach (Peak peak in peaks){
            string peakId = peak.id + "";
            if (summitedPeaks.ContainsKey(peakId)){
                List<Activity> activities = summitedPeaks[peakId];
                string activityIds = string.Join(", ", activities.Select(x => "<a href=https://www.strava.com/activities/" + x.id + ">" + x.id + "</a>"));
                string popupMessage = $@"Climbed {activities.Count} time{((activities.Count > 1) ? 's' : ' ')} <br>
                                        Activity ids: {activityIds}";

                await UpdateMarker(peak, "green", popupMessage);
            } else {
                if (!markers.ContainsKey(peakId)){
                    await UpdateMarker(peak, "grey", "");
                }
            }
        }
    }

    private async Task UpdateMarker(Peak peak, String color, String popupMessage){
        string peakId = peak.id + "";
        if (markers.ContainsKey(peakId))
        {
            await markers[peakId].Remove();
            markers.Remove(peakId);
        }
        Marker marker = await createPeakMarker(peak, color);
        if (!String.IsNullOrEmpty(popupMessage))
        {
            await marker.BindPopup(popupMessage);
        }
        markers.TryAdd(peak.id + "", marker);
    }

    public static IconOptions coloredIconOptions(string color)
    {
        return new IconOptions()
            {
                IconUrl = "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-" + color + ".png",
                ShadowUrl = "https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png",
                IconSize = new FisSst.BlazorMaps.Point(25, 41),
                IconAnchor = new FisSst.BlazorMaps.Point(12, 41),
                PopupAnchor = new FisSst.BlazorMaps.Point(1, -34),
                ShadowSize = new FisSst.BlazorMaps.Point(41, 41),
            };
    } 

    public async Task<MarkerOptions> coloredMarkerOptions(string color)
    {
        return new MarkerOptions()
            {
                Opacity = 1,
                Draggable = false,
                IconRef = await IconFactory.Create(coloredIconOptions(color)),
            };
    }

    public async Task<Marker> createPeakMarker(Peak peak, string markerColor){
        MarkerOptions markerOptions = await coloredMarkerOptions(markerColor);
        Marker marker = await MarkerFactory.CreateAndAddToMap(new LatLng(peak.location.coordinates[1], peak.location.coordinates[0]), mapRef, markerOptions);
        string alt_name = peak.name_sapmi ?? peak.name_alt;
        string tooltip = peak.name + (alt_name != null ?  " (" + alt_name + ")" : "") + (peak.elevation != null ? ", " + peak.elevation + "m" : "");
        await marker.BindTooltip(tooltip);
        return marker;
    } *@
@* } *@
